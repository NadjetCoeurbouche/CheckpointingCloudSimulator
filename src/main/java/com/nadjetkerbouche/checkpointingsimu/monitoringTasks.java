package com.nadjetkerbouche.checkpointingsimu;

import static com.nadjetkerbouche.checkpointingsimu.BestVmsList.bestVmsList;
import static com.nadjetkerbouche.checkpointingsimu.Final_List.finalVmsList;
import static com.nadjetkerbouche.checkpointingsimu.VM_SLA_data_UI.slaList;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.Timer;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Nadjet KERBOUCHE
 */
public class monitoringTasks extends javax.swing.JFrame {

    int progress;
    int lastCheckpoint;
    int normal_lastCheckpoint;
       int sla_ID;
    int vm_ID;
    String response_time_expected;
   String checkpoint_interval;
   float interval;
    float finalExeTimeResult;
Final_List final_list_object = new Final_List();
    BestVmsList bestVMs = new BestVmsList();

    /**
     * Creates new form monitoringTasks
     */
    public monitoringTasks() throws InterruptedException {
        initComponents();
        exeTable();
    }
     VM_SLA_data_UI vm_sla = new  VM_SLA_data_UI();

     
     // fill execution table function
    public void exeTable(){
     
    DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
        DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();

    Object data [] = new Object [finalVmsList.size()];
     Object dataNOFT [] = new Object [finalVmsList.size()];

    int b=0;
   float responstime =0;
   // getting data from the final list
       for (int i = 0; i < finalVmsList.size(); i++) {
            while (b < vm_sla.slaList.size()) {                
                   if(finalVmsList.get(i).slaID == vm_sla.slaList.get(b).slaID){
                    deadline = vm_sla.slaList.get(b).deadline;
                     responstime = finalVmsList.get(i).responseTimeExpected;
                 }  
                   b++;
                }
            b=0;
                   /* for (int ik = 0; ik < finalVmsList.size(); ik++) {
                        System.out.println("final l " + finalVmsList.get(ik));
                    }*/
  response_time_expected = final_list_object.convertTime(finalVmsList.get(i).responseTimeExpected);
    checkpoint_interval = final_list_object.convertTime(finalVmsList.get(i).interval);
data[0] = finalVmsList.get(i).slaID;

data[1] = finalVmsList.get(i).vmID;
data[2] = responstime;
data[3] = deadline;
data[4] = "";
data[5] = "";
data[6] = "";
data[7] = "pending";

 exeModel.addRow(data);

dataNOFT[0] = finalVmsList.get(i).slaID;

dataNOFT[1] = finalVmsList.get(i).vmID;
dataNOFT[2] = responstime;
dataNOFT[3] = deadline;
dataNOFT[4] = "";
dataNOFT[5] = "";
dataNOFT[6] = "pending";
 noFTExeModel.addRow(dataNOFT);
 }
     }

    
       
   
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        runTasksButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        timerLabel = new javax.swing.JLabel();
        stopTimerButton = new javax.swing.JButton();
        FailurePercentageTF = new javax.swing.JTextField();
        faultOccurrenceTF = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        fault_tolerance_button = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        exeTable = new javax.swing.JTable();
        jLabel4 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        totalPenLabel = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        noFTTable = new javax.swing.JTable();
        jLabel7 = new javax.swing.JLabel();
        totalCostNoCheckpointing = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(187, 225, 250));

        jPanel1.setBackground(new java.awt.Color(187, 225, 250));

        runTasksButton.setText("Run tasks");
        runTasksButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runTasksButtonActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel1.setText("Failure percentage: ");

        jLabel2.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel2.setText("Fault occurence (miliseconds):");

        timerLabel.setFont(new java.awt.Font("Segoe UI", 0, 36)); // NOI18N
        timerLabel.setText(" 00:00:00");

        stopTimerButton.setText("Stop timer");
        stopTimerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopTimerButtonActionPerformed(evt);
            }
        });

        FailurePercentageTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FailurePercentageTFActionPerformed(evt);
            }
        });

        faultOccurrenceTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                faultOccurrenceTFActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jLabel1)
                        .addGap(107, 107, 107))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addContainerGap(110, Short.MAX_VALUE)
                        .addComponent(jLabel2)
                        .addGap(68, 68, 68)))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(FailurePercentageTF, javax.swing.GroupLayout.PREFERRED_SIZE, 232, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(1, 1, 1)
                        .addComponent(faultOccurrenceTF, javax.swing.GroupLayout.PREFERRED_SIZE, 231, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(35, 35, 35)
                .addComponent(runTasksButton)
                .addGap(67, 67, 67)
                .addComponent(timerLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(stopTimerButton)
                .addGap(32, 32, 32))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(18, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(FailurePercentageTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(47, 47, 47)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(faultOccurrenceTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(stopTimerButton)
                            .addComponent(timerLabel)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addComponent(runTasksButton)))
                .addGap(13, 13, 13))
        );

        jLabel3.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        jLabel3.setText("Monitoring");

        fault_tolerance_button.setText("Fault tolerance");
        fault_tolerance_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fault_tolerance_buttonActionPerformed(evt);
            }
        });

        exeTable.setFont(new java.awt.Font("Verdana", 1, 14)); // NOI18N
        exeTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Task ID", "VM ID", "Response Time", "Deadline", "Last checkpoint", "penalty cost", "Case", "Status", "New VM ID "
            }
        ));
        exeTable.setGridColor(new java.awt.Color(255, 255, 255));
        jScrollPane1.setViewportView(exeTable);

        jLabel4.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel4.setText("With Checkpointing");

        jLabel6.setText("Total Penalty cost: ");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addGap(143, 143, 143)
                        .addComponent(jLabel6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(totalPenLabel)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 625, Short.MAX_VALUE)
                        .addGap(14, 14, 14))))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jLabel6)
                    .addComponent(totalPenLabel))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 159, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(121, Short.MAX_VALUE))
        );

        jLabel5.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel5.setText("Without Checkpointing");

        noFTTable.setFont(new java.awt.Font("Verdana", 1, 14)); // NOI18N
        noFTTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Task ID", "VM ID", "Response time", "Deadline", "penalty cost", "Case", "Status", "New VM ID"
            }
        ));
        noFTTable.setGridColor(new java.awt.Color(255, 255, 255));
        jScrollPane2.setViewportView(noFTTable);

        jLabel7.setText("Total Penaly cost:");

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 601, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addComponent(jLabel5)
                        .addGap(86, 86, 86)
                        .addComponent(jLabel7)
                        .addGap(18, 18, 18)
                        .addComponent(totalCostNoCheckpointing)))
                .addContainerGap(28, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jLabel7)
                    .addComponent(totalCostNoCheckpointing))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 159, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(120, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(123, 123, 123)
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(33, 33, 33)
                        .addComponent(fault_tolerance_button))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(1206, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(fault_tolerance_button))
                        .addGap(28, 28, 28))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(22, 22, 22)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void runTasksButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runTasksButtonActionPerformed
               DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
               DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();

 for(int oo=0; oo< exeModel.getRowCount(); oo++){
    exeModel.setValueAt("in progress", oo, 7);
       noFTExeModel.setValueAt("in progress", oo, 6);

    }
    timer.start();
    
        t1.start();
    }//GEN-LAST:event_runTasksButtonActionPerformed

    private void stopTimerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopTimerButtonActionPerformed
            timer.stop();
            
        // TODO add your handling code here:
    }//GEN-LAST:event_stopTimerButtonActionPerformed

    private void FailurePercentageTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FailurePercentageTFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_FailurePercentageTFActionPerformed

    private void faultOccurrenceTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_faultOccurrenceTFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_faultOccurrenceTFActionPerformed

    private void fault_tolerance_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fault_tolerance_buttonActionPerformed
    

        fault_tolerance();
without_FT();
   // TODO add your handling code here:
    }//GEN-LAST:event_fault_tolerance_buttonActionPerformed

    
    
    String failureP ;
   String failureO;
    int fp;
 ArrayList<FailedTask> failedTasksList = null;
  
 // injecting faults
 public void failure(){
        
        DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
        DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();

        failureP = FailurePercentageTF.getText().toString();
         fp = (int) Integer.parseInt(failureP) ;
         
        int s = exeModel.getRowCount()-1;
        
      // calculate int number of vm failed
        int vmFailure = (vm_sla.slaList.size() * fp )/100;
       int nbvf = vm_sla.slaList.size() - vmFailure;
     
        // change the status field of the task
        while (s >= nbvf) {
                    exeModel.setValueAt("failed", s, 7); 
                    noFTExeModel.setValueAt("failed", s, 6); 
                    s--;
        }
        // store failed tasks data in failedTasksList arrayList
 failedTasksList = new ArrayList<FailedTask>();

        for(int i = 0; i< exeModel.getRowCount(); i++){

            if( exeModel.getValueAt(i, 7) == "failed"){
    
                int taskId = Integer.parseInt( exeModel.getValueAt(i, 0).toString());
                   int vmID = Integer.parseInt((String) exeModel.getValueAt(i, 1).toString());
                    FailedTask failedTaskObj = new FailedTask(taskId, vmID,fp);

                    failedTasksList.add(failedTaskObj);  

}          
}
        
    }
 
    long startingRunTime = 0; //400 seconds
    //float timeLeft = finalVmsList.get(1).responseTimeExpected;
    
    public String fill_interval(float interval) throws InterruptedException{

        String intervalString = final_list_object.convertTime(interval);
        return intervalString;


    }   
    

    // Thread to for checking latest checkpoint
    Thread t1 = new Thread(new Runnable() {
    @Override
    public void run() {
            float interval = finalVmsList.get(2).interval;

            DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();

       /* try {          
            for(int i =0; i<5; i++){
            exeModel.setValueAt(fill_interval(interval), 2, 4); 
            t1.sleep((long)(finalVmsList.get(2).interval*1000));
                interval = interval + interval ;
            }
        } catch (InterruptedException ex) {
            Logger.getLogger(monitoringTasks.class.getName()).log(Level.SEVERE, null, ex);
        } // code goes here.*/
}
});  
    // Global timer action
ActionListener counter = new ActionListener()
{
    public void actionPerformed(ActionEvent e)
{              
    DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();

   
        startingRunTime += 1000;
       // timeLeft -= 1;
        SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss");
        String st =  df.format(startingRunTime);
      //  String tl = final_list_object.convertTime(timeLeft);
        
 timerLabel.setText(st);
     /*   try {
            exeModel.setValueAt(fill_interval(timeLeft), 1, 3);
        } catch (InterruptedException ex) {
            Logger.getLogger(monitoringTasks.class.getName()).log(Level.SEVERE, null, ex);
        }*/
    int fp =  Integer.parseInt(faultOccurrenceTF.getText().toString());
  if(startingRunTime == fp)
        {
            failure();
        }
     
     
        if(startingRunTime >= 400000)
        {
            timer.stop();
        }
    }
};       
Timer timer = new Timer(1000,counter);

      ArrayList<Final_List> updatedList = new ArrayList<Final_List>();
    int vCPU = 0;
    int ins_count = 0;
     float new_response_time;
     float previouseResponseTime;
    float exePercentage;
    float last_checkpoint;
      int j=0;
       int nbInsLeft;
   int newVCPU; 
   int slaID ;
                   int vmID;
                float faultPercentage;
                float responseTimeExpected;
                float penaltycostFactor;
                float checkpointing;
                int s;
                int newBestListSize;
                int l;
                int i = 0;    
                int b;
                 float wasted_time;
float final_exe_time ;
 int deadline;
 float penalty_cost;
              String approach_case;
               float penaltyPercentage1;
    float penaltyPercentage2;
    float penaltyPercentage3;
    float totalPenaltyCost;
    float Sumpenalty_costFailed;
    float Sumpenalty_costNormal;
    int fo;
int price;
float loss;
float totalLoss = 0;
float totalLossNoFt =0;
 ArrayList<CheckpointingFinalResultsClass> resultsList = new ArrayList<CheckpointingFinalResultsClass>();

  // updating failed tasks to new virtual machines
  public void fault_tolerance(){
    
    DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
      String fault_occurrence_time =  faultOccurrenceTF.getText().toString();
               fo = (int) Integer.parseInt(fault_occurrence_time) ;

       Object data [] = new Object [vm_sla.slaList.size()];                   
                  l = finalVmsList.size(); 
                  int sizeFailed = failedTasksList.size();
                s = exeModel.getRowCount() - sizeFailed;
 // new machine 
       while( i < failedTasksList.size()){
           // checking for available new machine 
               if(bestVmsList.get(l).vmID != failedTasksList.get(i).vmID){
                   
                   
         slaID = failedTasksList.get(i).taskId;
         vmID = bestVmsList.get(l).vmID ;
         faultPercentage = bestVmsList.get(l).faultPercentage;
         String status = "in progress";
        
         while (j < vm_sla.vmList.size()) {
                if(failedTasksList.get(i).vmID == vm_sla.vmList.get(j).vmID){
                                vCPU =  vm_sla.vmList.get(j).computeCapacity;

                }                      
                j++;

         }
         b=0;
                          //extract SLA details  
                while (b < vm_sla.slaList.size()) {
                    if(failedTasksList.get(i).taskId == vm_sla.slaList.get(b).slaID){
                   ins_count =  vm_sla.slaList.get(b).instructionCount;       
                    deadline = vm_sla.slaList.get(b).deadline;
                     price =  vm_sla.slaList.get(b).price;
                       penaltyPercentage1 = vm_sla.slaList.get(b).penaltyPercentage1;
                        penaltyPercentage2 = vm_sla.slaList.get(b).penaltyPercentage2;
                        penaltyPercentage3 = vm_sla.slaList.get(b).penaltyPercentage3;
                     penalty_cost = (penaltyPercentage1+penaltyPercentage2+penaltyPercentage3)* price;

                        System.out.println(" price : " + price);
                }
                      b++;
                }
                
                // calculate response time    
               previouseResponseTime = (int)(ins_count / vCPU);

               // getting last checkpoint    
                int p2 =0;
                
        while( p2 < finalVmsList.size()){
           if(finalVmsList.get(p2).slaID == failedTasksList.get(i).taskId){
             interval = finalVmsList.get(p2).interval;
             
           }
           p2++;
        }
                   System.out.println(interval + " -------------------- interva in sec " );

                lastCheckpoint =  (int) ((int)((fo/1000)/interval)  * interval);
                   System.out.println(lastCheckpoint + " lastCheckpoint in sec " );

                // getting execution percentage of the failed task
                exePercentage = (lastCheckpoint * 100)/ previouseResponseTime;
               System.out.println(exePercentage+ " exePercentage " );

             // getting instruction count left
              nbInsLeft = (int) ((100 - exePercentage )* ins_count)/100; 
                   System.out.println("nb ins left " + nbInsLeft );
                 
                   int o = 0;
                   System.out.println("an vm id " + vmID);
                   while(o < VM_SLA_data_UI.vmList.size()){
                    if(vmID == VM_SLA_data_UI.vmList.get(o).vmID){
                          newVCPU = VM_SLA_data_UI.vmList.get(o).computeCapacity;

                   }     
                    o++;   

                   }
                               System.out.println(" newVCPU " + newVCPU );


            new_response_time = nbInsLeft / newVCPU;
            System.out.println(" new_response_time " + new_response_time );


            wasted_time = (fo/1000) - lastCheckpoint;
            
                        System.out.println(" wasted_time " + wasted_time );
                        
           final_exe_time = lastCheckpoint + wasted_time + new_response_time;

 

float delay1 = (float) (0.1 * deadline) + deadline;
float delay2 = (float) (0.25 * deadline) + deadline;
float delay3 = (float) (0.50 * deadline) + deadline;

       if(deadline >= final_exe_time){
                                 approach_case = "no penalty";
                                 loss = 0;
}
else {
    if (final_exe_time > deadline &&  final_exe_time <= delay1 ){
    penalty_cost = ((penaltyPercentage1 + penaltyPercentage1 + penaltyPercentage2 + penaltyPercentage3) /4) * price;
                                    approach_case = "case 1";
                                    loss = penaltyPercentage1*price;

    }
    else if (final_exe_time > delay1 &&  final_exe_time <= delay2 ) {
            penalty_cost = ((penaltyPercentage1 + penaltyPercentage2 + penaltyPercentage2 + penaltyPercentage3) /4) * price;
                                    loss = penaltyPercentage2*price;

                                 approach_case = "case 2";


    }
    else {
              penalty_cost = ((penaltyPercentage1 + penaltyPercentage3 + penaltyPercentage2 + penaltyPercentage3) /4) * price;
                                    loss = penaltyPercentage3*price;

                                    approach_case = "case 3";

    }
       }
                               System.out.println(" price : " + price);

       float sumNormalResTime = 0;
       float sumFailedTaskResTime = 0;

        

 int kb=0;
 // to display normal tasks
         while( kb < (finalVmsList.size()- failedTasksList.size())){
             Sumpenalty_costNormal += finalVmsList.get(kb).totalPenalty;
             sumNormalResTime +=  finalVmsList.get(kb).responseTimeExpected;
               interval = finalVmsList.get(kb).interval;  
               status =finalVmsList.get(kb).status;

               if( status == "no penalty confirmed"){
               penalty_cost = 0;
               }
             normal_lastCheckpoint =  (int) ((int)((fo/1000)/interval)  * interval);
             exeModel.setValueAt(final_list_object.convertTime((int)normal_lastCheckpoint), kb, 4);
             exeModel.setValueAt(penalty_cost, kb, 5);
             exeModel.setValueAt( status, kb, 6);
                          exeModel.setValueAt( "Done", kb, 7);


           kb++;
}


    


CheckpointingFinalResultsClass checkpointingResultsObject = new CheckpointingFinalResultsClass (sla_ID, final_exe_time, loss, price, faultPercentage, approach_case);
                resultsList.add(checkpointingResultsObject);
                
     data[2] = final_exe_time ;

     data[4] = final_list_object.convertTime((int) lastCheckpoint); 
    
     data[5] = loss;           
     data[6] = approach_case ;
     data[7] =  "Done";
     data[8] = vmID;

     exeModel.setValueAt(data[2], s, 2);
     exeModel.setValueAt(data[4], s, 4);
     exeModel.setValueAt(data[5], s, 5);
     exeModel.setValueAt(data[6], s, 6);
     exeModel.setValueAt(data[7], s, 7);
     exeModel.setValueAt(data[8], s, 8);

                 s++;     
                 l++;
          
Final_List updatedfinalListObject = new Final_List  (slaID, vmID, faultPercentage, final_exe_time, loss, checkpointing, interval,
                       "in progress" );
             
    
     updatedList.add(updatedfinalListObject);
     
    
           
      finalExeTimeResult = sumFailedTaskResTime + sumNormalResTime;


  
 }  
 
      
           
                             i++;
     }  
   finalExecutionStatistics();


    
 }       

  
            public void finalExecutionStatistics(){
            DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
            DefaultTableModel noFTExeModel = (DefaultTableModel)exeTable.getModel();

             for (int kbs = 0; kbs < slaList.size(); kbs++){
        float sum = Float.parseFloat(exeModel.getValueAt(kbs, 5)+"");
        float sumNOFT = Float.parseFloat(noFTExeModel.getValueAt(kbs, 5)+"");

        totalLoss += sum;
    }
               
       totalPenLabel.setText( totalLoss + " DA");
              totalCostNoCheckpointing.setText( totalLossNoFt + " DA");            

            }
            
               public void finalExecutionStatisticsNOFT(){
            DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();

             for (int kbs = 0; kbs < slaList.size(); kbs++){
        float sumNOFT = Float.parseFloat(noFTExeModel.getValueAt(kbs, 4)+"");

        totalLossNoFt += sumNOFT;
    }
               
              totalCostNoCheckpointing.setText( totalLossNoFt + " DA");            

            }
            
                   int vCPU2 = 0;
int ins_count2 = 0;
 float new_response_time2;
  int j2=0;
   int nbInsLeft2;
int newVCPU2; 
int slaID2;
                float wasted_time2;

               int vmID2;
            float faultPercentage2;
            float responseTimeExpected2;
            float penaltycostFactor2;
            int s2;
            int l2 = finalVmsList.size();
            int i2 = 0;    
            int b2;
float final_exe_time2;
int deadline2;
float penalty_cost2;
          String approach_case2;
           float penaltyPercentage1noFT;
float penaltyPercentage2noFT;
float penaltyPercentage3noFT;
float totalPenaltyCost2;
float Sumpenalty_costFailed2;
float Sumpenalty_costNormal2;
int fo2;
int price2;
float loss2;
               
 private void without_FT() {
   System.out.println("new vm without ft" );
     
       
         DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();
     
     

            String fault_occurrence_time =  faultOccurrenceTF.getText().toString();
               fo2 = (int) Integer.parseInt(fault_occurrence_time) ;

       Object data [] = new Object [vm_sla.slaList.size()];                   
                  int sizeFailed = failedTasksList.size();
                s2 = noFTExeModel.getRowCount() - sizeFailed;
    // new machine 
       while( i2 < failedTasksList.size()){
           // checking for available new machine 
               if(bestVmsList.get(l2).vmID != failedTasksList.get(i2).vmID){

         slaID2 = failedTasksList.get(i2).taskId;
         vmID2 = bestVmsList.get(l2).vmID ;
         faultPercentage2 = bestVmsList.get(l2).faultPercentage;
         String status = "in progress";
        
         while (j2 < vm_sla.vmList.size()) {
                if(failedTasksList.get(i2).vmID == vm_sla.vmList.get(j2).vmID){
                                vCPU2 =  vm_sla.vmList.get(j2).computeCapacity;

                }                      
                j2++;

         }
         b2=0;
             
                    //extract SLA details  
                while (b2 < vm_sla.slaList.size()) {
                    if(failedTasksList.get(i2).taskId == vm_sla.slaList.get(b2).slaID){
                   ins_count2 =  vm_sla.slaList.get(b2).instructionCount;       
                    deadline2 = vm_sla.slaList.get(b2).deadline;
                     price2 =  vm_sla.slaList.get(b2).price;
                       penaltyPercentage1noFT = vm_sla.slaList.get(b2).penaltyPercentage1;
                        penaltyPercentage2noFT = vm_sla.slaList.get(b2).penaltyPercentage2;
                        penaltyPercentage3noFT = vm_sla.slaList.get(b2).penaltyPercentage3;
                     penalty_cost2 = (penaltyPercentage1noFT + penaltyPercentage2noFT + penaltyPercentage3noFT)* price;

                }
                      b2++;
                }
                
            
                   int o = 0;
                   while(o < VM_SLA_data_UI.vmList.size()){
                    if(vmID2 == VM_SLA_data_UI.vmList.get(o).vmID){
                          newVCPU2 = VM_SLA_data_UI.vmList.get(o).computeCapacity;

                   }     
                    o++;   

                   }


            new_response_time2 = ins_count2 / newVCPU2;


                wasted_time2 = (fo/1000);
            
                        
           final_exe_time2 = wasted_time2 + new_response_time2;


float delay1 = (float) (0.1 * deadline2) + deadline2;
float delay2 = (float) (0.25 * deadline2) + deadline2;
float delay3 = (float) (0.50 * deadline2) + deadline2;

       if(deadline2 >= final_exe_time2){
                                 approach_case2 = "no penalty";
                                 loss2 = 0;
}
else {
    if (final_exe_time2 > deadline2 &&  final_exe_time2 <= delay1 ){
    penalty_cost2 = ((penaltyPercentage1noFT + penaltyPercentage1noFT + penaltyPercentage2noFT + penaltyPercentage3noFT) /4) * price2;
                                    approach_case2 = "case 1";
                                    loss2 = penaltyPercentage1noFT * price2;

    }
    else if (final_exe_time > delay1 &&  final_exe_time <= delay2 ) {
            penalty_cost2 = ((penaltyPercentage1noFT + penaltyPercentage2noFT + penaltyPercentage2noFT + penaltyPercentage3noFT) /4) * price2;
                                    loss2 = penaltyPercentage2noFT * price2;

                                 approach_case2 = "case 2";


    }
    else {
           penalty_cost2 = ((penaltyPercentage1noFT + penaltyPercentage3noFT + penaltyPercentage2noFT + penaltyPercentage3noFT) /4) * price2;
                                    loss2 = penaltyPercentage3noFT * price2;

                                 approach_case2 = "case 3";
    }
       }

       float sumNormalResTime = 0;
       float sumFailedTaskResTime = 0;

        

 int kb=0;
 // to display normal tasks
         while( kb < (finalVmsList.size()- failedTasksList.size())){
            status =finalVmsList.get(kb).status;

               if( status == "no penalty confirmed"){
               penalty_cost = 0;
               }
             noFTExeModel.setValueAt(penalty_cost, kb, 4);
             noFTExeModel.setValueAt( status, kb, 5);
                          noFTExeModel.setValueAt( "Done", kb, 6);


           kb++;
}


    noFTExeModel.setValueAt(final_exe_time2, s2, 2);
      noFTExeModel.setValueAt(loss2, s2, 4);
     noFTExeModel.setValueAt(approach_case2, s2, 5);
     noFTExeModel.setValueAt("Done", s2, 6);
     noFTExeModel.setValueAt(vmID2, s2, 7);

                 s2++;     
                 l2++;
          

     
 }  
                             i2++;
     }  

       finalExecutionStatisticsNOFT();
               

  
 }           

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField FailurePercentageTF;
    private javax.swing.JTable exeTable;
    private javax.swing.JTextField faultOccurrenceTF;
    private javax.swing.JButton fault_tolerance_button;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTable noFTTable;
    private javax.swing.JButton runTasksButton;
    private javax.swing.JButton stopTimerButton;
    private javax.swing.JLabel timerLabel;
    private javax.swing.JLabel totalCostNoCheckpointing;
    private javax.swing.JLabel totalPenLabel;
    // End of variables declaration//GEN-END:variables

   
}