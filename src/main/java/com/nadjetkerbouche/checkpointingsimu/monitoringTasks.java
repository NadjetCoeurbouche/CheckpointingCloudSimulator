package com.nadjetkerbouche.checkpointingsimu;

import static com.nadjetkerbouche.checkpointingsimu.BestVmsList.bestVmsList;
import static com.nadjetkerbouche.checkpointingsimu.Final_List.finalVmsList;
import static com.nadjetkerbouche.checkpointingsimu.VM_SLA_data_UI.slaList;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.Timer;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Nadjet KERBOUCHE
 */
public class monitoringTasks extends javax.swing.JFrame {

    int progress;
    int lastCheckpoint;
    int normal_lastCheckpoint;
       int sla_ID;
    int vm_ID;
    String response_time_expected;
   String checkpoint_interval;
   float interval;
    float finalExeTimeResult;
Final_List final_list_object = new Final_List();
    BestVmsList bestVMs = new BestVmsList();

    /**
     * Creates new form monitoringTasks
     */
    public monitoringTasks() throws InterruptedException {
        initComponents();
        exeTable();
    }
     VM_SLA_data_UI vm_sla = new  VM_SLA_data_UI();

     
     // fill execution table function
    public void exeTable(){
     
        DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
        DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();
        DefaultTableModel fixedChExeModel = (DefaultTableModel)FixedCheckPointTable.getModel();

    Object data [] = new Object [finalVmsList.size()];
     Object dataNOFT [] = new Object [finalVmsList.size()];
     Object dataFixedCheckpointing [] = new Object [finalVmsList.size()];

    int b=0;
   float responstime =0;
   // getting data from the final list
       for (int i = 0; i < finalVmsList.size(); i++) {
            while (b < vm_sla.slaList.size()) {                
                   if(finalVmsList.get(i).slaID == vm_sla.slaList.get(b).slaID){
                    deadline = vm_sla.slaList.get(b).deadline;
                     responstime = finalVmsList.get(i).responseTimeExpected;
                 }  
                   b++;
                }
            b=0;
                   /* for (int ik = 0; ik < finalVmsList.size(); ik++) {
                        System.out.println("final l " + finalVmsList.get(ik));
                    }*/
  response_time_expected = final_list_object.convertTime(finalVmsList.get(i).responseTimeExpected);
    checkpoint_interval = final_list_object.convertTime(finalVmsList.get(i).interval);
data[0] = finalVmsList.get(i).slaID;

data[1] = finalVmsList.get(i).vmID;
data[2] = responstime;
data[3] = deadline;
data[4] = "";
data[5] = "";
data[6] = "";
data[7] = "pending";

 exeModel.addRow(data);

dataNOFT[0] = finalVmsList.get(i).slaID;
dataNOFT[1] = finalVmsList.get(i).vmID;
dataNOFT[2] = responstime;
dataNOFT[3] = deadline;
dataNOFT[4] = "";
dataNOFT[5] = "";
dataNOFT[6] = "pending";
noFTExeModel.addRow(dataNOFT);

dataFixedCheckpointing[0] = finalVmsList.get(i).slaID;
dataFixedCheckpointing[1] = finalVmsList.get(i).vmID;
dataFixedCheckpointing[2] = "";
dataFixedCheckpointing[3] = responstime;
dataFixedCheckpointing[4] = deadline;
dataFixedCheckpointing[5] = "";
dataFixedCheckpointing[6] = "";
dataFixedCheckpointing[7] = "";
dataFixedCheckpointing[8] = "pending";
fixedChExeModel.addRow(dataFixedCheckpointing);

 }
     }

    
       
   
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jProgressBar1 = new javax.swing.JProgressBar();
        jScrollPane4 = new javax.swing.JScrollPane();
        jPanel3 = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        runTasksButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        timerLabel = new javax.swing.JLabel();
        stopTimerButton = new javax.swing.JButton();
        FailurePercentageTF = new javax.swing.JTextField();
        faultOccurrenceTF = new javax.swing.JTextField();
        fixedChIntervalTF = new javax.swing.JTextField();
        checkpointSavingTimeTF = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        fault_tolerance_button = new javax.swing.JButton();
        jPanel4 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        noFTTable = new javax.swing.JTable();
        jLabel7 = new javax.swing.JLabel();
        totalCostNoCheckpointing = new javax.swing.JLabel();
        noFTslaVio = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        FixedCheckPointTable = new javax.swing.JTable();
        fixedChLabel = new javax.swing.JLabel();
        totalCostFixed = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        exeTable = new javax.swing.JTable();
        jLabel4 = new javax.swing.JLabel();
        slaViolation = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        totalPenLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(187, 225, 250));

        jPanel3.setBackground(new java.awt.Color(255, 255, 255));
        jPanel3.setToolTipText("Monitoring");

        jPanel1.setBackground(new java.awt.Color(187, 225, 250));

        runTasksButton.setText("Run tasks");
        runTasksButton.setOpaque(true);
        runTasksButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runTasksButtonActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel1.setText("Failure percentage: ");

        jLabel2.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel2.setText("Fixed Checkpoint interval (miliseconds):");

        timerLabel.setFont(new java.awt.Font("Segoe UI", 0, 36)); // NOI18N
        timerLabel.setText(" 00:00:00");

        stopTimerButton.setText("Stop timer");
        stopTimerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopTimerButtonActionPerformed(evt);
            }
        });

        FailurePercentageTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FailurePercentageTFActionPerformed(evt);
            }
        });

        faultOccurrenceTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                faultOccurrenceTFActionPerformed(evt);
            }
        });

        fixedChIntervalTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fixedChIntervalTFActionPerformed(evt);
            }
        });

        jLabel8.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel8.setText("Fault occurence (miliseconds):");

        jLabel9.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel9.setText("Checkpoint Saving Time  (miliseconds):");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(35, 35, 35)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(jLabel2)
                                .addComponent(jLabel9))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(9, 9, 9)
                                .addComponent(runTasksButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(timerLabel)))
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(stopTimerButton)
                                .addGap(23, 23, 23))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(65, 65, 65)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(checkpointSavingTimeTF, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(fixedChIntervalTF, javax.swing.GroupLayout.PREFERRED_SIZE, 176, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel8)
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(FailurePercentageTF, javax.swing.GroupLayout.DEFAULT_SIZE, 176, Short.MAX_VALUE)
                            .addComponent(faultOccurrenceTF))))
                .addContainerGap(12, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(8, 8, 8)
                        .addComponent(FailurePercentageTF, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel8, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(faultOccurrenceTF, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(fixedChIntervalTF, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(checkpointSavingTimeTF, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel9)))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(timerLabel)
                    .addComponent(stopTimerButton)
                    .addComponent(runTasksButton))
                .addContainerGap(33, Short.MAX_VALUE))
        );

        jLabel3.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        jLabel3.setText("Monitoring");

        fault_tolerance_button.setText("Fault tolerance");
        fault_tolerance_button.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        fault_tolerance_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fault_tolerance_buttonActionPerformed(evt);
            }
        });

        jPanel4.setBackground(new java.awt.Color(255, 255, 255));

        jLabel5.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel5.setText("Without Checkpointing");

        noFTTable.setFont(new java.awt.Font("Verdana", 1, 14)); // NOI18N
        noFTTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Task ID", "VM ID", "Response time", "Deadline", "penalty cost", "Case", "Status", "New VM ID"
            }
        ));
        noFTTable.setGridColor(new java.awt.Color(255, 255, 255));
        jScrollPane2.setViewportView(noFTTable);

        jLabel7.setText("Total Penaly cost:");

        noFTslaVio.setText("jLabel8");

        FixedCheckPointTable.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        FixedCheckPointTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Task ID", "VM ID", "New VM ID", "Response Time", "Deadline", "Last Checkpoint", "Penalty cost", "Penalty case", "Progress Status"
            }
        ));
        FixedCheckPointTable.setGridColor(new java.awt.Color(255, 255, 255));
        jScrollPane3.setViewportView(FixedCheckPointTable);

        fixedChLabel.setText("jLabel10");

        totalCostFixed.setText("jLabel10");

        jLabel10.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel10.setText("Fixed Checkpointing Interval");

        exeTable.setFont(new java.awt.Font("Verdana", 1, 14)); // NOI18N
        exeTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Task ID", "VM ID", "Response Time", "Deadline", "Last checkpoint", "penalty cost", "Case", "Status", "New VM ID "
            }
        ));
        exeTable.setGridColor(new java.awt.Color(255, 255, 255));
        jScrollPane1.setViewportView(exeTable);

        jLabel4.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel4.setText("With Checkpointing");

        slaViolation.setText("jLabel8");

        jLabel6.setText("Total Penalty cost: ");

        totalPenLabel.setText("jLabel11");

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel4Layout.createSequentialGroup()
                                .addGap(450, 450, 450)
                                .addComponent(totalCostNoCheckpointing))
                            .addGroup(jPanel4Layout.createSequentialGroup()
                                .addComponent(jLabel5)
                                .addGap(99, 99, 99)
                                .addComponent(jLabel7)
                                .addGap(33, 33, 33)
                                .addComponent(totalPenLabel)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 388, Short.MAX_VALUE)
                        .addComponent(noFTslaVio)
                        .addGap(147, 147, 147))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.LEADING))
                        .addContainerGap())
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addGap(130, 130, 130)
                        .addComponent(jLabel6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(slaViolation)
                        .addGap(143, 143, 143))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                        .addComponent(jLabel10)
                        .addGap(109, 109, 109)
                        .addComponent(totalCostFixed)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(fixedChLabel)
                        .addGap(137, 137, 137))))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(totalCostNoCheckpointing)
                        .addComponent(noFTslaVio))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel7)
                            .addComponent(jLabel5)
                            .addComponent(totalPenLabel))))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(slaViolation)
                    .addComponent(jLabel6))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 26, Short.MAX_VALUE)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(fixedChLabel)
                    .addComponent(totalCostFixed)
                    .addComponent(jLabel10))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 190, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(23, 23, 23))
        );

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(81, 81, 81)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(fault_tolerance_button, javax.swing.GroupLayout.PREFERRED_SIZE, 166, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 164, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(192, 192, 192))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(47, 47, 47)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(18, 18, 18)
                        .addComponent(fault_tolerance_button, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        jScrollPane4.setViewportView(jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 1230, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 999, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void fault_tolerance_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fault_tolerance_buttonActionPerformed

        fault_tolerance();
        without_FT();
        FixedCheckpointing();
        // TODO add your handling code here:
    }//GEN-LAST:event_fault_tolerance_buttonActionPerformed

    private void fixedChIntervalTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fixedChIntervalTFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_fixedChIntervalTFActionPerformed

    private void faultOccurrenceTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_faultOccurrenceTFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_faultOccurrenceTFActionPerformed

    private void FailurePercentageTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FailurePercentageTFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_FailurePercentageTFActionPerformed

    private void stopTimerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopTimerButtonActionPerformed
        timer.stop();

        // TODO add your handling code here:
    }//GEN-LAST:event_stopTimerButtonActionPerformed

    private void runTasksButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runTasksButtonActionPerformed
        DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
        DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();
        DefaultTableModel fixedChExeModel = (DefaultTableModel)FixedCheckPointTable.getModel();

        for(int oo=0; oo< exeModel.getRowCount(); oo++){
            exeModel.setValueAt("in progress", oo, 7);
            noFTExeModel.setValueAt("in progress", oo, 6);
            fixedChExeModel.setValueAt("in progress", oo, 8);
        }
        timer.start();

        t1.start();
    }//GEN-LAST:event_runTasksButtonActionPerformed

    
    
    String failureP ;
   String failureO;
    int fp;
 ArrayList<FailedTask> failedTasksList = null;
  
 // injecting faults
 public void failure(){
        
        DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
        DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();
        DefaultTableModel fixedChExeModel = (DefaultTableModel)FixedCheckPointTable.getModel();
        String fault_occurrence_time =  faultOccurrenceTF.getText().toString();
        float fo = (float) Integer.parseInt(fault_occurrence_time)/1000 ;

        failureP = FailurePercentageTF.getText().toString();
         fp = (int) Integer.parseInt(failureP) ;
         
        int s = exeModel.getRowCount()-1;
        int s2 = exeModel.getRowCount()-1;
        int s3 = exeModel.getRowCount()-1;
        int m = exeModel.getRowCount()-1;
        int m2 = exeModel.getRowCount()-1;
        int m3 = exeModel.getRowCount()-1;
      // calculate int number of vm failed
        int vmFailure = (vm_sla.slaList.size() * fp )/100;
       int nbvf = vm_sla.slaList.size() - vmFailure;
     
        // change the status field of the task
                while (s > 0) {         
            if(fo <= (float) exeModel.getValueAt(s, 2) && m >= nbvf ){
                     exeModel.setValueAt("failed", s, 7); 
                        m--; 
            }
                   

                     
                s--;


     }
                    while (s > 0) {         
            if(fo <= (float) exeModel.getValueAt(s, 2) && m >= nbvf ){
                     exeModel.setValueAt("failed", s, 7); 
                        m--; 
            }
                   

                     
                s--;


     }
                    
                        while (s2 > 0) {         
            if(fo <= (float)noFTExeModel.getValueAt(s2, 2)  && m2 >= nbvf ){
                    noFTExeModel.setValueAt("failed", s2, 6);
                    m2--; 
            }
                   

                     
                s2--;


     }
       
 
            while (s3 > 0) {         
            if(fo <= (float)fixedChExeModel.getValueAt(s3, 3) && m3 >= nbvf ){
                    fixedChExeModel.setValueAt("failed", s3, 8);       
                    m3--; 
            }
                             
                s3--;


     }
         
    
        // store failed tasks data in failedTasksList arrayList
 failedTasksList = new ArrayList<FailedTask>();

        for(int i = 0; i< exeModel.getRowCount(); i++){

            if( exeModel.getValueAt(i, 7) == "failed"){
    
                int taskId = Integer.parseInt( exeModel.getValueAt(i, 0).toString());
                   int vmID = Integer.parseInt((String) exeModel.getValueAt(i, 1).toString());
                    FailedTask failedTaskObj = new FailedTask(taskId, vmID,fp);

                    failedTasksList.add(failedTaskObj);  

}          
}
        
    }
 
    long startingRunTime = 0; //400 seconds
    //float timeLeft = finalVmsList.get(1).responseTimeExpected;
    
    public String fill_interval(float interval) throws InterruptedException{

        String intervalString = final_list_object.convertTime(interval);
        return intervalString;


    }   
    

    // Thread to for checking latest checkpoint
    Thread t1 = new Thread(new Runnable() {
    @Override
    public void run() {
            float interval = finalVmsList.get(2).interval;

            DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();

       /* try {          
            for(int i =0; i<5; i++){
            exeModel.setValueAt(fill_interval(interval), 2, 4); 
            t1.sleep((long)(finalVmsList.get(2).interval*1000));
                interval = interval + interval ;
            }
        } catch (InterruptedException ex) {
            Logger.getLogger(monitoringTasks.class.getName()).log(Level.SEVERE, null, ex);
        } // code goes here.*/
}
});  
    // Global timer action
ActionListener counter = new ActionListener()
{
    public void actionPerformed(ActionEvent e)
{              
    DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();

   
        startingRunTime += 1000;
       // timeLeft -= 1;
        SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss");
        String st =  df.format(startingRunTime);
      //  String tl = final_list_object.convertTime(timeLeft);
        
 timerLabel.setText(st);
     /*   try {
            exeModel.setValueAt(fill_interval(timeLeft), 1, 3);
        } catch (InterruptedException ex) {
            Logger.getLogger(monitoringTasks.class.getName()).log(Level.SEVERE, null, ex);
        }*/
    int fp =  Integer.parseInt(faultOccurrenceTF.getText().toString());
  if(startingRunTime == fp)
        {
            failure();
        }
     
     
        if(startingRunTime >= 400000)
        {
            timer.stop();
        }
    }
};       
Timer timer = new Timer(1000,counter);

      ArrayList<Final_List> updatedList = new ArrayList<Final_List>();
    int vCPU = 0;
    int ins_count = 0;
     float new_response_time;
     float previouseResponseTime;
    float exePercentage;
    float last_checkpoint;
      int j=0;
       int nbInsLeft;
   int newVCPU; 
   int slaID ;
                   int vmID;
                float faultPercentage;
                float responseTimeExpected;
                float penaltycostFactor;
                float checkpointing;
                int s;
                int newBestListSize;
                int l;
                int i = 0;    
                int b;
                 float wasted_time;
float final_exe_time ;
 int deadline;
 float penalty_cost;
              String approach_case;
               float penaltyPercentage1;
    float penaltyPercentage2;
    float penaltyPercentage3;
    float totalPenaltyCost;
    float Sumpenalty_costFailed;
    float Sumpenalty_costNormal;
    int fo;
int price;
float loss;
float totalLoss = 0;
float totalLossNoFt =0;
 ArrayList<CheckpointingFinalResultsClass> resultsList = new ArrayList<CheckpointingFinalResultsClass>();

  // updating failed tasks to new virtual machines
  public void fault_tolerance(){
    
    DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
      String fault_occurrence_time =  faultOccurrenceTF.getText().toString();
               fo = (int) Integer.parseInt(fault_occurrence_time) ;

       Object data [] = new Object [vm_sla.slaList.size()];                   
                  l = finalVmsList.size(); 
                  int sizeFailed = failedTasksList.size();
                s = exeModel.getRowCount() - sizeFailed;
 // new machine 
       while( i < failedTasksList.size()){
           // checking for available new machine 
               if(bestVmsList.get(l).vmID != failedTasksList.get(i).vmID){
                   
                   
         slaID = failedTasksList.get(i).taskId;
         vmID = bestVmsList.get(l).vmID ;
         faultPercentage = bestVmsList.get(l).faultPercentage;
         String status = "in progress";
        
         while (j < vm_sla.vmList.size()) {
                if(failedTasksList.get(i).vmID == vm_sla.vmList.get(j).vmID){
                                vCPU =  vm_sla.vmList.get(j).computeCapacity;

                }                      
                j++;

         }
         b=0;
                          //extract SLA details  
                while (b < vm_sla.slaList.size()) {
                    if(failedTasksList.get(i).taskId == vm_sla.slaList.get(b).slaID){
                   ins_count =  vm_sla.slaList.get(b).instructionCount;       
                    deadline = vm_sla.slaList.get(b).deadline;
                     price =  vm_sla.slaList.get(b).price;
                       penaltyPercentage1 = vm_sla.slaList.get(b).penaltyPercentage1;
                        penaltyPercentage2 = vm_sla.slaList.get(b).penaltyPercentage2;
                        penaltyPercentage3 = vm_sla.slaList.get(b).penaltyPercentage3;
                     penalty_cost = (penaltyPercentage1+penaltyPercentage2+penaltyPercentage3)* price;

                }
                      b++;
                }
                
                // calculate response time    
               previouseResponseTime = (int)(ins_count / vCPU);

               // getting last checkpoint    
                int p2 =0;
                
        while( p2 < finalVmsList.size()){
           if(finalVmsList.get(p2).slaID == failedTasksList.get(i).taskId){
             interval = finalVmsList.get(p2).interval;
             
           }
           p2++;
        }

                lastCheckpoint =  (int) ((int)((fo/1000)/interval)  * interval);

                // getting execution percentage of the failed task
                exePercentage = (lastCheckpoint * 100)/ previouseResponseTime;

             // getting instruction count left
              nbInsLeft = (int) ((100 - exePercentage )* ins_count)/100; 
                 
                   int o = 0;
                   while(o < VM_SLA_data_UI.vmList.size()){
                    if(vmID == VM_SLA_data_UI.vmList.get(o).vmID){
                          newVCPU = VM_SLA_data_UI.vmList.get(o).computeCapacity;

                   }     
                    o++;   

                   }


            new_response_time = nbInsLeft / newVCPU;

            wasted_time = (fo/1000) - lastCheckpoint;
                                    
           final_exe_time = lastCheckpoint + wasted_time + new_response_time;

 

float delay1 = (float) (0.1 * deadline) + deadline;
float delay2 = (float) (0.25 * deadline) + deadline;
float delay3 = (float) (0.50 * deadline) + deadline;

       if(deadline >= final_exe_time){
                                 approach_case = "no penalty";
                                 loss = 0;
}
else {
    if (final_exe_time > deadline &&  final_exe_time <= delay1 ){
    penalty_cost = ((penaltyPercentage1 + penaltyPercentage1 + penaltyPercentage2 + penaltyPercentage3) /4) * price;
                                    approach_case = "case 1";
                                    loss = penaltyPercentage1*price;

    }
    else if (final_exe_time > delay1 &&  final_exe_time <= delay2 ) {
            penalty_cost = ((penaltyPercentage1 + penaltyPercentage2 + penaltyPercentage2 + penaltyPercentage3) /4) * price;
                                    loss = penaltyPercentage2*price;

                                 approach_case = "case 2";


    }
    else {
              penalty_cost = ((penaltyPercentage1 + penaltyPercentage3 + penaltyPercentage2 + penaltyPercentage3) /4) * price;
                                    loss = penaltyPercentage3*price;

                                    approach_case = "case 3";

    }
       }

       float sumNormalResTime = 0;
       float sumFailedTaskResTime = 0;

        

 int kb=0;
 // to display normal tasks
         while( kb < (finalVmsList.size()- failedTasksList.size())){
             Sumpenalty_costNormal += finalVmsList.get(kb).totalPenalty;
             sumNormalResTime +=  finalVmsList.get(kb).responseTimeExpected;
               interval = finalVmsList.get(kb).interval;  
               status =finalVmsList.get(kb).status;

               if( status == "no penalty"){
               penalty_cost = 0;
               }
             normal_lastCheckpoint =  (int) ((int)((fo/1000)/interval)  * interval);
             exeModel.setValueAt(final_list_object.convertTime((int)normal_lastCheckpoint), kb, 4);
             exeModel.setValueAt(penalty_cost, kb, 5);
             exeModel.setValueAt( status, kb, 6);
                          exeModel.setValueAt( "Done", kb, 7);


           kb++;
}


    


CheckpointingFinalResultsClass checkpointingResultsObject = new CheckpointingFinalResultsClass (sla_ID, final_exe_time, loss, price, faultPercentage, approach_case);
                resultsList.add(checkpointingResultsObject);
                
     data[2] = final_list_object.convertTime((int)final_exe_time) ;

     data[4] = final_list_object.convertTime((int) lastCheckpoint); 
    
     data[5] = loss;           
     data[6] = approach_case ;
     data[7] =  "Done";
     data[8] = vmID;

     exeModel.setValueAt(data[2], s, 2);
     exeModel.setValueAt(data[4], s, 4);
     exeModel.setValueAt(data[5], s, 5);
     exeModel.setValueAt(data[6], s, 6);
     exeModel.setValueAt(data[7], s, 7);
     exeModel.setValueAt(data[8], s, 8);

                 s++;     
                 l++;
          
Final_List updatedfinalListObject = new Final_List  (slaID, vmID, faultPercentage, final_exe_time, loss, checkpointing, interval,
                       "in progress" );
             
    
     updatedList.add(updatedfinalListObject);
     
    
           
      finalExeTimeResult = sumFailedTaskResTime + sumNormalResTime;


  
 }  
 
      
           
                             i++;
     }  
   finalExecutionStatistics();


    
 }       

  
            public void finalExecutionStatistics(){
            DefaultTableModel exeModel = (DefaultTableModel)exeTable.getModel();
           int slaVio = 0;
             for (int kbs = 0; kbs < slaList.size(); kbs++){
        float sum = Float.parseFloat(exeModel.getValueAt(kbs, 5)+"");
        totalLoss += sum;
        if(exeModel.getValueAt(kbs, 6) != "no penalty"){
           slaVio++;
        }
        
    }
               
       totalPenLabel.setText( totalLoss + " DA");
       slaViolation.setText("SLA Violation " + slaVio);
              totalCostNoCheckpointing.setText( totalLossNoFt + " DA");            

            }
            
               public void finalExecutionStatisticsNOFT(){
            DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();
           int slaVio = 0;

             for (int kbs = 0; kbs < slaList.size(); kbs++){
        float sumNOFT = Float.parseFloat(noFTExeModel.getValueAt(kbs, 4)+"");

        totalLossNoFt += sumNOFT;
         if(noFTExeModel.getValueAt(kbs, 5) != "no penalty"){
           slaVio++;
        }
    }
                  noFTslaVio.setText("SLA Violation " + slaVio);

              totalCostFixed.setText( totalLossNoFt + " DA");            

            }
             float  totalLossFixed;
               
            public void finalExecutionStatisticsFixed(){
        DefaultTableModel fixedChExeModel = (DefaultTableModel)FixedCheckPointTable.getModel();
           int slaVio = 0;

             for (int kbs = 0; kbs < slaList.size(); kbs++){
        float sumFixed = Float.parseFloat(fixedChExeModel.getValueAt(kbs, 6)+"");

        totalLossFixed += sumFixed;
         if(fixedChExeModel.getValueAt(kbs, 7) != "no penalty"){
           slaVio++;
        }
    }
              fixedChLabel.setText("SLA Violation " + slaVio);

              totalCostNoCheckpointing.setText( totalLossFixed + " DA");            

            
            }
            
               int vCPU2 = 0;
int ins_count2 = 0;
 float new_response_time2;
  int j2=0;
   int nbInsLeft2;
int newVCPU2; 
int slaID2;
                float wasted_time2;

               int vmID2;
            float faultPercentage2;
            float responseTimeExpected2;
            float penaltycostFactor2;
            int s2;
            int l2 = finalVmsList.size();
            int i2 = 0;    
            int b2;
float final_exe_time2;
int deadline2;
float penalty_cost2;
          String approach_case2;
           float penaltyPercentage1noFT;
float penaltyPercentage2noFT;
float penaltyPercentage3noFT;
float totalPenaltyCost2;
float Sumpenalty_costFailed2;
float Sumpenalty_costNormal2;
int fo2;
int price2;
float loss2;
               
 private void without_FT() {
     
       
         DefaultTableModel noFTExeModel = (DefaultTableModel)noFTTable.getModel();
     
     

            String fault_occurrence_time =  faultOccurrenceTF.getText().toString();
               fo2 = (int) Integer.parseInt(fault_occurrence_time) ;

       Object data [] = new Object [vm_sla.slaList.size()];                   
                  int sizeFailed = failedTasksList.size();
                s2 = noFTExeModel.getRowCount() - sizeFailed;
    // new machine 
       while( i2 < failedTasksList.size()){
           // checking for available new machine 
               if(bestVmsList.get(l2).vmID != failedTasksList.get(i2).vmID){

         slaID2 = failedTasksList.get(i2).taskId;
         vmID2 = bestVmsList.get(l2).vmID ;
         faultPercentage2 = bestVmsList.get(l2).faultPercentage;
         String status = "in progress";
        
         while (j2 < vm_sla.vmList.size()) {
                if(failedTasksList.get(i2).vmID == vm_sla.vmList.get(j2).vmID){
                                vCPU2 =  vm_sla.vmList.get(j2).computeCapacity;

                }                      
                j2++;

         }
         b2=0;
             
                    //extract SLA details  
                while (b2 < vm_sla.slaList.size()) {
                    if(failedTasksList.get(i2).taskId == vm_sla.slaList.get(b2).slaID){
                   ins_count2 =  vm_sla.slaList.get(b2).instructionCount;       
                    deadline2 = vm_sla.slaList.get(b2).deadline;
                     price2 =  vm_sla.slaList.get(b2).price;
                       penaltyPercentage1noFT = vm_sla.slaList.get(b2).penaltyPercentage1;
                        penaltyPercentage2noFT = vm_sla.slaList.get(b2).penaltyPercentage2;
                        penaltyPercentage3noFT = vm_sla.slaList.get(b2).penaltyPercentage3;
                     penalty_cost2 = (penaltyPercentage1noFT + penaltyPercentage2noFT + penaltyPercentage3noFT)* price;

                }
                      b2++;
                }
                
            
                   int o = 0;
                   while(o < VM_SLA_data_UI.vmList.size()){
                    if(vmID2 == VM_SLA_data_UI.vmList.get(o).vmID){
                          newVCPU2 = VM_SLA_data_UI.vmList.get(o).computeCapacity;

                   }     
                    o++;   

                   }


            new_response_time2 = ins_count2 / newVCPU2;


                wasted_time2 = (fo/1000);
            
                        
           final_exe_time2 = wasted_time2 + new_response_time2;


float delay1 = (float) (0.1 * deadline2) + deadline2;
float delay2 = (float) (0.25 * deadline2) + deadline2;
float delay3 = (float) (0.50 * deadline2) + deadline2;

       if(deadline2 >= final_exe_time2){
                                 approach_case2 = "no penalty";
                                 loss2 = 0;
}
else {
    if (final_exe_time2 > deadline2 &&  final_exe_time2 <= delay1 ){
    penalty_cost2 = ((penaltyPercentage1noFT + penaltyPercentage1noFT + penaltyPercentage2noFT + penaltyPercentage3noFT) /4) * price2;
                                    approach_case2 = "case 1";
                                    loss2 = penaltyPercentage1noFT * price2;

    }
    else if (final_exe_time > delay1 &&  final_exe_time <= delay2 ) {
            penalty_cost2 = ((penaltyPercentage1noFT + penaltyPercentage2noFT + penaltyPercentage2noFT + penaltyPercentage3noFT) /4) * price2;
                                    loss2 = penaltyPercentage2noFT * price2;

                                 approach_case2 = "case 2";


    }
    else {
           penalty_cost2 = ((penaltyPercentage1noFT + penaltyPercentage3noFT + penaltyPercentage2noFT + penaltyPercentage3noFT) /4) * price2;
                                    loss2 = penaltyPercentage3noFT * price2;

                                 approach_case2 = "case 3";
    }
       }

       float sumNormalResTime = 0;
       float sumFailedTaskResTime = 0;

        

 int kb=0;
 // to display normal tasks
         while( kb < (finalVmsList.size()- failedTasksList.size())){
            status =finalVmsList.get(kb).status;

               if( status == "no penalty"){
               penalty_cost = 0;
               }
             noFTExeModel.setValueAt(penalty_cost, kb, 4);
             noFTExeModel.setValueAt( status, kb, 5);
                          noFTExeModel.setValueAt( "Done", kb, 6);


           kb++;
}


    noFTExeModel.setValueAt(final_list_object.convertTime((int)final_exe_time2), s2, 2);
      noFTExeModel.setValueAt(loss2, s2, 4);
     noFTExeModel.setValueAt(approach_case2, s2, 5);
     noFTExeModel.setValueAt("Done", s2, 6);
     noFTExeModel.setValueAt(vmID2, s2, 7);

                 s2++;     
                 l2++;
          

     
 }  
                             i2++;
     }  

       finalExecutionStatisticsNOFT();
               

  
 }           
 
 
           
               int vCPU3 = 0;
int ins_count3 = 0;
 float new_response_time3;
  int j3=0;
   int nbInsLeft3;
int newVCPU3; 
int slaID3;
      float wasted_time3;

               int vmID3;
            float faultPercentage3;
            float responseTimeExpected3;
            float penaltycostFactor3;
            int s3;
            int l3 = finalVmsList.size();
            int i3 = 0;    
            int b3;
float final_exe_time3;
int deadline3;
float penalty_cost3;
          String approach_case3;
           float penaltyPercentage1Fixed3;
float penaltyPercentage2Fixed;
float penaltyPercentage3Fixed;
float totalPenaltyCost3;
float Sumpenalty_costFailed3;
float Sumpenalty_costNormal3;
int fo3;
int price3;
float loss3;
      int interval3;
int lastCheckpoint3 ;
float exePercentage3;
int saving_ch_time;
float previouseResponseTime3;

 private void FixedCheckpointing() {
   
             DefaultTableModel fixedChExeModel = (DefaultTableModel)FixedCheckPointTable.getModel();

            String fault_occurrence_time =  faultOccurrenceTF.getText().toString();
             String saving_checkpoint_time =  checkpointSavingTimeTF.getText().toString();
            String fixed_interval =  fixedChIntervalTF.getText().toString();

               fo3 = (int) Integer.parseInt(fault_occurrence_time) /1000 ;
               interval3 = (int) Integer.parseInt(fixed_interval) /1000 ;
               saving_ch_time = (int) Integer.parseInt(saving_checkpoint_time)/1000 ;

       Object data [] = new Object [vm_sla.slaList.size()];                   
                  int sizeFailed = failedTasksList.size();
                s3 = fixedChExeModel.getRowCount() - sizeFailed;
    // new machine 
       while( i3 < failedTasksList.size()){
           // checking for available new machine 
               if(bestVmsList.get(l3).vmID != failedTasksList.get(i3).vmID){

         slaID3 = failedTasksList.get(i3).taskId;
         vmID3 = bestVmsList.get(l3).vmID ;
         faultPercentage3 = bestVmsList.get(l3).faultPercentage;
         String status = "in progress";
        
         
         while (j3 < vm_sla.vmList.size()) {
                if(failedTasksList.get(i3).vmID == vm_sla.vmList.get(j3).vmID){
                                vCPU3 =  vm_sla.vmList.get(j3).computeCapacity;

                }                      
                j3++;

         }
         b3=0;
             

           
                    //extract SLA details  
                while (b3 < vm_sla.slaList.size()) {
                    if(failedTasksList.get(i3).taskId == vm_sla.slaList.get(b3).slaID){
                   ins_count3 =  vm_sla.slaList.get(b3).instructionCount;       
                    deadline3 = vm_sla.slaList.get(b3).deadline;
                     price3 =  vm_sla.slaList.get(b3).price;
                       penaltyPercentage1Fixed3 = vm_sla.slaList.get(b3).penaltyPercentage1;
                        penaltyPercentage2Fixed = vm_sla.slaList.get(b3).penaltyPercentage2;
                        penaltyPercentage3Fixed = vm_sla.slaList.get(b3).penaltyPercentage3;
                     penalty_cost3 = (penaltyPercentage1Fixed3 + penaltyPercentage2Fixed + penaltyPercentage3Fixed)* price;

                }
                      b3++;
                }
                
                  
            
                   int o = 0;
                   while(o < VM_SLA_data_UI.vmList.size()){
                    if(vmID3 == VM_SLA_data_UI.vmList.get(o).vmID){
                          newVCPU3 = VM_SLA_data_UI.vmList.get(o).computeCapacity;

                   }     
                    o++;   

                   } 
                  
                   System.out.println( " fo 3 ------ " + fo3 );

                   System.out.println( " Interval 3 ------ " + interval3 );
                   
                   lastCheckpoint3 =  (int) ((int)(fo3/interval3) * interval3);
                  
                   System.out.println(lastCheckpoint3 + " lastCheckpoint in sec " );
                  
                   int totalCheckpoints = lastCheckpoint3 /interval3;
                 
                // calculate response time    
               previouseResponseTime3 = (int)(ins_count3 / vCPU3);
            
               // getting execution percentage of the failed task
                exePercentage3 = (lastCheckpoint3 * 100)/ previouseResponseTime3;
               System.out.println(exePercentage3 + " exePercentage " );

            new_response_time3 = ins_count3 / newVCPU3;

            // getting instruction count left
              nbInsLeft3 = (int) ((100 - exePercentage3 )* ins_count3)/100; 
              wasted_time3 = fo3 - lastCheckpoint3;
            int totalSavingChTime = totalCheckpoints * saving_ch_time;
                        
           final_exe_time3 = wasted_time3 + new_response_time3 + lastCheckpoint3 + totalSavingChTime ;


float delay1 = (float) (0.1 * deadline3) + deadline3;
float delay2 = (float) (0.25 * deadline3) + deadline3;
float delay3 = (float) (0.50 * deadline3) + deadline3;

       if(deadline3 >= final_exe_time3){
                                 approach_case3 = "no penalty";
                                 loss3 = 0;
}
else {
    if (final_exe_time3 > deadline3 &&  final_exe_time3 <= delay1 ){
    penalty_cost3 = ((penaltyPercentage1Fixed3 + penaltyPercentage1Fixed3+ penaltyPercentage2Fixed + penaltyPercentage3Fixed) /4) * price3;
                                    approach_case3 = "case 1";
                                    loss3 = penaltyPercentage1Fixed3 * price3;

    }
    else if (final_exe_time3 > delay1 &&  final_exe_time3 <= delay2 ) {
             penalty_cost3 = ((penaltyPercentage1Fixed3 + penaltyPercentage2Fixed+ penaltyPercentage2Fixed + penaltyPercentage3Fixed) /4) * price3;
                                    approach_case3 = "case 2";
                                    loss3 = penaltyPercentage2Fixed * price3;
    }
    else {
              penalty_cost3 = ((penaltyPercentage1Fixed3 + penaltyPercentage3Fixed+ penaltyPercentage2Fixed + penaltyPercentage3Fixed) /4) * price3;
                                    approach_case3 = "case 3";
                                    loss3 = penaltyPercentage3Fixed * price3;
    }
       }

       float sumNormalResTime = 0;
       float sumFailedTaskResTime = 0;

        

 int kb=0;
 // to display normal tasks
         while( kb < (finalVmsList.size()- failedTasksList.size())){
            status =finalVmsList.get(kb).status;

               if( status == "no penalty"){
               penalty_cost3 = 0;
               }
           
               fixedChExeModel.setValueAt(final_list_object.convertTime((int)lastCheckpoint3), kb, 5);

             fixedChExeModel.setValueAt(penalty_cost3, kb, 6);
             fixedChExeModel.setValueAt( status, kb, 7);
             fixedChExeModel.setValueAt( "Done", kb, 8);


           kb++;
}


     fixedChExeModel.setValueAt(vmID3, s3, 2);
     fixedChExeModel.setValueAt(final_list_object.convertTime((int)final_exe_time3), s3, 3);
          fixedChExeModel.setValueAt(final_list_object.convertTime((int)lastCheckpoint3), s3, 5);

     fixedChExeModel.setValueAt(loss3, s3, 6);
     fixedChExeModel.setValueAt(approach_case3, s3, 7);
     fixedChExeModel.setValueAt("Done", s3, 8);

                 s3++;     
                 l3++;
          

     
 }  
                             i3++;
     }  

       finalExecutionStatisticsFixed();
               

  
 }           

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField FailurePercentageTF;
    private javax.swing.JTable FixedCheckPointTable;
    private javax.swing.JTextField checkpointSavingTimeTF;
    private javax.swing.JTable exeTable;
    private javax.swing.JTextField faultOccurrenceTF;
    private javax.swing.JButton fault_tolerance_button;
    private javax.swing.JTextField fixedChIntervalTF;
    private javax.swing.JLabel fixedChLabel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTable noFTTable;
    private javax.swing.JLabel noFTslaVio;
    private javax.swing.JButton runTasksButton;
    private javax.swing.JLabel slaViolation;
    private javax.swing.JButton stopTimerButton;
    private javax.swing.JLabel timerLabel;
    private javax.swing.JLabel totalCostFixed;
    private javax.swing.JLabel totalCostNoCheckpointing;
    private javax.swing.JLabel totalPenLabel;
    // End of variables declaration//GEN-END:variables

   
}